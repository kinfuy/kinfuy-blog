<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>ES6异步解决方案async函数 | 阿乐去买菜</title>
    <meta name="description" content="阿乐的笔记小屋！">
    <link rel="stylesheet" href="/assets/style.9910fb25.css">
    <link rel="modulepreload" href="/assets/app.5c9543e2.js">
    <link rel="modulepreload" href="/assets/views_article_Javascript_libs_async.md.3d2ff430.lean.js">
    
    <link rel="shortcut icon" href="/images/favicon.png">
  <meta name="twitter:title" content="ES6异步解决方案async函数 | 阿乐去买菜">
  <meta property="og:title" content="ES6异步解决方案async函数 | 阿乐去买菜">
  </head>
  <body>
    <div id="app"><div class="docs-content" data-v-ff8a130e><div class="home-nav" style="background-color:#fff;42fdde49:#333;601e8cdb:#7dd1d3;" data-v-ff8a130e data-v-186b6f8a><div class="home-operate" data-v-186b6f8a><!--[--><a class="operate-item" href="/" data-v-186b6f8a>Home</a><a class="operate-item" href="/views/article/index.html" data-v-186b6f8a>Blog</a><a class="operate-item" href="/views/about.html" data-v-186b6f8a>About</a><!--]--><a class="operate-btn" href="https://github.com/alqmc" target="_blank" data-v-186b6f8a><i class="svg-icon" style="font-size:26px;" data-v-186b6f8a><!--[--><svg class="icon" viewbox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" data-v-186b6f8a><path fill="currentColor" d="M511.6 76.3C264.3 76.2 64 276.4 64 523.5 64 718.9 189.3 885 363.8 946c23.5 5.9 19.9-10.8 19.9-22.2v-77.5c-135.7 15.9-141.2-73.9-150.3-88.9C215 726 171.5 718 184.5 703c30.9-15.9 62.4 4 98.9 57.9 26.4 39.1 77.9 32.5 104 26 5.7-23.5 17.9-44.5 34.7-60.8-140.6-25.2-199.2-111-199.2-213 0-49.5 16.3-95 48.3-131.7-20.4-60.5 1.9-112.3 4.9-120 58.1-5.2 118.5 41.6 123.2 45.3 33-8.9 70.7-13.6 112.9-13.6 42.4 0 80.2 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.3-43.9 2.9 7.7 24.7 58.3 5.5 118 32.4 36.8 48.9 82.7 48.9 132.3 0 102.2-59 188.1-200 212.9 23.5 23.2 38.1 55.4 38.1 91v112.5c0.8 9 0 17.9 15 17.9 177.1-59.7 304.6-227 304.6-424.1 0-247.2-200.4-447.3-447.5-447.3z"></path></svg><!--]--></i></a></div></div><div class="docs-bodyer" data-v-ff8a130e><div class="article-content" data-v-ff8a130e data-v-6f2c7da3><div class="article-nav-tag" data-v-6f2c7da3><!--[--><a href="/views/article/index.html" class="tag-item" data-v-6f2c7da3>All</a><a href="/views/article/Vuejs/index.html" class="tag-item" data-v-6f2c7da3>Vuejs</a><a href="/views/article/Javascript/index.html" class="tag-item tag-active" data-v-6f2c7da3>Javascript</a><a href="/views/article/Nodejs/index.html" class="tag-item" data-v-6f2c7da3>Nodejs</a><a href="/views/article/Tool/index.html" class="tag-item" data-v-6f2c7da3>Tool</a><a href="/views/article/InformalEssay/index.html" class="tag-item" data-v-6f2c7da3>InformalEssay</a><!--]--></div><div style="position:relative;" data-v-6f2c7da3><div><h2 id="es6-异步解决方案-async-函数" tabindex="-1">ES6 异步解决方案 async 函数 <a class="header-anchor" href="#es6-异步解决方案-async-函数" aria-hidden="true">#</a></h2><h3 id="generator-函数" tabindex="-1">Generator 函数 <a class="header-anchor" href="#generator-函数" aria-hidden="true">#</a></h3><p>要说到 async 函数就得从 Generator 函数说起，Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。Generator 函数有多种理解角度。从语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p><p>形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function 关键字与函数名之间有一个星号；二是，函数体内部使用 yield 语句，定义不同的内部状态（yield 语句在英语里的意思就是“产出”）。</p><div class="language-js"><pre><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">ImGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">yield</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">;</span>
  <span class="token keyword">yield</span> <span class="token string">&#39;world&#39;</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token string">&#39;ending&#39;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> fun <span class="token operator">=</span> <span class="token function">ImGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>上面代码定义了一个<strong>Generator</strong>函数 ImGenerator，它内部有两个<strong>yield</strong>语句“hello”和“world”，即该函数有三个状态：hello，world 和 return 语句（结束执行）。</p><div class="language-js"><pre><code>fun<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// { value: &#39;hello&#39;, done: false }</span>

fun<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// { value: &#39;world&#39;, done: false }</span>

fun<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// { value: &#39;ending&#39;, done: true }</span>

fun<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// { value: undefined, done: true }</span>
</code></pre></div><p>Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象必须调用遍历器对象的 next 方法，使得指针移向下一个状态。也就是说，每次调用 next 方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个 yield 语句（或 return 语句）为止。换言之，Generator 函数是分段执行的，yield 语句是暂停执行的标记，而 next 方法可以恢复执行。</p><p><strong>yield 语句</strong>,由于 Generator 函数返回的遍历器对象，只有调用 next 方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield 语句就是暂停标志。</p><p>（1）遇到 yield 语句，就暂停执行后面的操作，并将紧跟在 yield 后面的那个表达式的值，作为返回的对象的 value 属性值。</p><p>（2）下一次调用 next 方法时，再继续往下执行，直到遇到下一个 yield 语句。</p><p>（3）如果没有再遇到新的 yield 语句，就一直运行到函数结束，直到 return 语句为止，并将 return 语句后面的表达式的值，作为返回的对象的 value 属性值。</p><p>（4）如果该函数没有 return 语句，则返回的对象的 value 属性值为 undefined。</p><div class="language-js"><pre><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">yield</span> <span class="token number">123</span> <span class="token operator">+</span> <span class="token number">456</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上面代码中，yield 后面的表达式 123 + 456，不会立即求值，只会在 next 方法将指针移到这一句时，才会求值。yield 语句后面的表达式，只有当调用 next 方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。</p><p>yield 语句与 return 语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到 yield，函数暂停执行，下一次再从该位置继续向后执行，而 return 语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）return 语句，但是可以执行多次（或者说多个）yield 语句。正常函数只能返回一个值，因为只能执行一次 return；Generator 函数可以返回一系列的值，因为可以有任意多个 yield。从另一个角度看，也可以说 Generator 生成了一系列的值，这也就是它的名称的来历（在英语中，generator 这个词是“生成器”的意思）。</p><p>Generator 函数可以不用 yield 语句，这时就变成了一个单纯的暂缓执行函数。</p><div class="language-js"><pre><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;执行了！&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> generator <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  generator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>函数 f 如果是普通函数，在为变量 generator 赋值时就会执行。但是，函数 f 是一个 Generator 函数，就变成只有调用 next 方法时，函数 f 才会执行。</p><p>另外需要注意，yield 语句不能用在普通函数中，否则会报错。</p><h3 id="async-函数" tabindex="-1">async 函数 <a class="header-anchor" href="#async-函数" aria-hidden="true">#</a></h3><p>ES7 提供了 async 函数，使得异步操作变得更加方便。async 函数是什么？一句话，async 函数就是前文 Generator 函数的语法糖。</p><p>前文有一个 Generator 函数</p><div class="language-js"><pre><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">ImGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">yield</span> <span class="token function">Fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">yield</span> <span class="token function">Fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">yield</span> <span class="token function">Fun3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> fun <span class="token operator">=</span> <span class="token function">ImGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>写成 async 函数，就是下面这样。</p><div class="language-js"><pre><code><span class="token keyword">async</span> <span class="token function">ImGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">await</span> <span class="token function">Fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">await</span> <span class="token function">Fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">await</span> <span class="token function">Fun3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> fun <span class="token operator">=</span> <span class="token function">ImGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>一比较就会发现，async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await，仅此而已。</p><p>async 函数对 Generator 函数的改进，体现在以下四点。</p><p>（1）内置执行器。Generator 函数的执行必须靠执行器，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。 (上面的代码调用了 ImGenerator 函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用 next 方法，才能得到真正执行，得到最后结果。)</p><p>（2）更好的语义。async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。</p><p>（4）返回值是 Promise。async 函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用 then 方法指定下一步的操作。</p><p>进一步说，async 函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而 await 命令就是内部 then 命令的语法糖。</p><h3 id="async-函数简单用法" tabindex="-1">async 函数简单用法 <a class="header-anchor" href="#async-函数简单用法" aria-hidden="true">#</a></h3><p>async 函数的语法规则总体上比较简单，难点是错误处理机制</p><p>（1）async 函数返回一个 Promise 对象,async 函数内部 return 语句返回的值，会成为 then 方法回调函数的参数。</p><div class="language-js"><pre><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">Fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token string">&#39;hello world&#39;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">Fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// &quot;hello world&quot;</span>
</code></pre></div><p>上面代码中，函数 Fun 内部 return 命令返回的值，会被 then 方法回调函数接收到。</p><p>async 函数内部抛出错误，会导致返回的 Promise 对象变为 reject 状态。抛出的错误对象会被 catch 方法回调函数接收到。</p><div class="language-js"><pre><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">Fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&#39;出错了&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">Fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Error: 出错了</span>
</code></pre></div><p>（2）async 函数返回的 Promise 对象，必须等到内部所有 await 命令的 Promise 对象执行完，才会发生状态改变。也就是说，只有 async 函数内部的异步操作执行完，才会执行 then 方法指定的回调函数。</p><p>（3）正常情况下，await 命令后面是一个 Promise 对象。如果不是，会被转成一个立即 resolve 的 Promise 对象。</p><h3 id="async-函数简单实现（generator-函数）" tabindex="-1">async 函数简单实现（Generator 函数） <a class="header-anchor" href="#async-函数简单实现（generator-函数）" aria-hidden="true">#</a></h3><div class="language-js"><pre><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token comment">// 等同于</span>

<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">spawn</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="注意" tabindex="-1">注意 <a class="header-anchor" href="#注意" aria-hidden="true">#</a></h3><p>(1) await 命令后面的 Promise 对象，运行结果可能是 rejected，所以最好把 await 命令放在 try...catch 代码块中。</p><div class="language-js"><pre><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">await</span> <span class="token function">somethingThatReturnsAPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 另一种写法</span>

<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">await</span> <span class="token function">somethingThatReturnsAPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>(2)多个 await 命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</p><p>(3) await 命令只能用在 async 函数之中，如果用在普通函数，就会报错。</p></div></div><div class="copy-right" data-v-6f2c7da3> 本文首发于 <a href="https://alqmc.github.io/" data-v-6f2c7da3>@阿乐去买菜</a>，转载请署名出处 </div></div></div></div></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"index.md\":\"7a93947b\",\"views_about.md\":\"0e5f0818\",\"views_article_informalessay_index.md\":\"3b975a9b\",\"views_article_informalessay_libs_2021.md\":\"8e4c177b\",\"views_article_informalessay_libs_lowcodedesigner.md\":\"c3f735a7\",\"views_article_informalessay_libs_lowcodesetter.md\":\"d1ce3bbc\",\"views_article_informalessay_libs_lowcodestart.md\":\"257b6262\",\"views_article_informalessay_libs_lowcodedesiger.md\":\"9e2a811f\",\"views_article_informalessay_libs_notes.md\":\"85bbb2bb\",\"views_article_informalessay_libs_px.md\":\"2f4d2abe\",\"views_article_informalessay_libs_qq.md\":\"cc3900ed\",\"views_article_javascript_index.md\":\"f1bf491a\",\"views_article_javascript_libs_angular.md\":\"6f2567b9\",\"views_article_javascript_libs_async.md\":\"3d2ff430\",\"views_article_javascript_libs_axios.md\":\"988d63b7\",\"views_article_javascript_libs_call-bind.md\":\"3d41c745\",\"views_article_javascript_libs_copy-code.md\":\"d431e0f6\",\"views_article_javascript_libs_csrf.md\":\"388848f9\",\"views_article_javascript_libs_decorator.md\":\"729d654d\",\"views_article_javascript_libs_eventloop.md\":\"ec723a50\",\"views_article_javascript_libs_foreach.md\":\"4e6c5ef0\",\"views_article_javascript_libs_leetcode-list.md\":\"32cbe4b1\",\"views_article_javascript_libs_leetcode-num.md\":\"b37789b9\",\"views_article_javascript_libs_leetcode-rect.md\":\"e68e50ae\",\"views_article_javascript_libs_module.md\":\"ac83f448\",\"views_article_javascript_libs_object.md\":\"b3d85837\",\"views_article_javascript_libs_promise.md\":\"c201d964\",\"views_article_javascript_libs_prototype.md\":\"f6a6f023\",\"views_article_javascript_libs_queen.md\":\"54671968\",\"views_article_javascript_libs_response-header.md\":\"20f068c6\",\"views_article_nodejs_index.md\":\"14bb06f8\",\"views_article_nodejs_libs_email.md\":\"59269b7d\",\"views_article_nodejs_libs_socket.md\":\"15b52418\",\"views_article_tool_index.md\":\"29edb1e8\",\"views_article_tool_libs_apiproxy.md\":\"cfcf405e\",\"views_article_tool_libs_chrome.md\":\"0df67aa4\",\"views_article_tool_libs_clear.md\":\"b4652646\",\"views_article_tool_libs_gacm.md\":\"9d58960e\",\"views_article_tool_libs_mangosteen.md\":\"374f2d17\",\"views_article_vuejs_index.md\":\"39eb1aaa\",\"views_article_vuejs_libs_inject.md\":\"65c358ae\",\"views_article_vuejs_libs_loadong.md\":\"71fe42eb\",\"views_article_vuejs_libs_offical.md\":\"07e56585\",\"views_article_vuejs_libs_rem.md\":\"504be5c9\",\"views_article_vuejs_libs_select.md\":\"2e830aaf\",\"views_article_vuejs_libs_slot.md\":\"901440f6\",\"views_article_vuejs_libs_vitepress.md\":\"d3bd03a2\",\"views_article_vuejs_libs_vuehook.md\":\"48e3e7b8\",\"views_article_index.md\":\"08d9d8c9\",\"views_project_index.md\":\"a3b25a8d\"}")</script>
    <script type="module" async src="/assets/app.5c9543e2.js"></script>
    
  </body>
</html>